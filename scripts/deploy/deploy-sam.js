#!/usr/bin/env node
/**
 * SAM Deployment Script
 *
 * Deploys the LinkedIn Advanced Search backend via SAM.
 * - Prompts for configuration if not present
 * - Generates samconfig.toml
 * - Executes SAM build and deploy
 * - Captures outputs to .env file
 */

import { readFileSync, writeFileSync, existsSync } from 'fs';
import { execSync, spawn } from 'child_process';
import { createInterface } from 'readline';
import { resolve, join, dirname } from 'path';
import { fileURLToPath } from 'url';

// Derive PROJECT_ROOT from script location, not cwd()
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const PROJECT_ROOT = resolve(__dirname, '..', '..');  // scripts/deploy -> root
const BACKEND_DIR = join(PROJECT_ROOT, 'backend');
const CONFIG_FILE = '.deploy-config.json';

/**
 * Prompts user for input
 */
function prompt(question, defaultValue = '', isSecret = false) {
  const rl = createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  return new Promise((resolve) => {
    const displayQuestion = defaultValue && !isSecret
      ? `${question} [${defaultValue}]: `
      : `${question}: `;

    rl.question(displayQuestion, (answer) => {
      rl.close();
      resolve(answer.trim() || defaultValue);
    });
  });
}

/**
 * Loads existing configuration or returns defaults
 */
function loadConfig() {
  const configPath = join(PROJECT_ROOT, CONFIG_FILE);

  if (existsSync(configPath)) {
    try {
      const config = JSON.parse(readFileSync(configPath, 'utf-8'));
      console.log('âœ“ Loaded existing configuration from', CONFIG_FILE);
      return config;
    } catch (error) {
      console.warn('âš  Failed to parse existing config, starting fresh');
    }
  }

  return {
    stackName: 'linkedin-advanced-search',
    region: 'us-west-2',
    environment: 'prod',
    openaiApiKey: '',
    openaiWebhookSecret: '',
    ragstackEndpoint: '',
    ragstackApiKey: '',
  };
}

/**
 * Saves configuration to file (excludes secrets)
 */
function saveConfig(config) {
  const configPath = join(PROJECT_ROOT, CONFIG_FILE);
  // Don't persist secrets to disk
  const safeConfig = {
    stackName: config.stackName,
    region: config.region,
    environment: config.environment,
  };
  writeFileSync(configPath, JSON.stringify(safeConfig, null, 2));
  console.log('âœ“ Configuration saved to', CONFIG_FILE);
}

/**
 * Gets AWS account ID
 */
function getAwsAccountId() {
  try {
    const result = execSync('aws sts get-caller-identity --query Account --output text', {
      encoding: 'utf-8',
    });
    return result.trim();
  } catch (error) {
    throw new Error('Failed to get AWS account ID. Ensure AWS CLI is configured.');
  }
}

/**
 * Validates AWS credentials
 */
function validateAwsCredentials() {
  console.log('\nğŸ” Validating AWS credentials...');
  try {
    const identity = execSync('aws sts get-caller-identity --output json', {
      encoding: 'utf-8',
    });
    const parsed = JSON.parse(identity);
    console.log(`âœ“ Authenticated as: ${parsed.Arn}`);
    return true;
  } catch (error) {
    throw new Error('AWS credentials not configured or invalid. Run `aws configure` first.');
  }
}

/**
 * Validates SAM CLI is installed
 */
function validateSamCli() {
  console.log('\nğŸ”§ Checking SAM CLI...');
  try {
    const version = execSync('sam --version', { encoding: 'utf-8' });
    console.log(`âœ“ SAM CLI: ${version.trim()}`);
    return true;
  } catch (error) {
    throw new Error('SAM CLI not found. Install from https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/install-sam-cli.html');
  }
}

/**
 * Generates samconfig.toml for deployment
 */
function generateSamConfig(config, accountId) {
  const paramOverrides = [
    `Environment=${config.environment}`,
  ];

  if (config.openaiApiKey) {
    paramOverrides.push(`OpenAIApiKey=${config.openaiApiKey}`);
  }
  if (config.openaiWebhookSecret) {
    paramOverrides.push(`OpenAIWebhookSecret=${config.openaiWebhookSecret}`);
  }
  if (config.ragstackEndpoint) {
    paramOverrides.push(`RagstackGraphqlEndpoint=${config.ragstackEndpoint}`);
  }
  if (config.ragstackApiKey) {
    paramOverrides.push(`RagstackApiKey=${config.ragstackApiKey}`);
  }

  const samConfig = `# Auto-generated by deploy-sam.js
# Do not edit manually

version = 0.1

[default.deploy.parameters]
stack_name = "${config.stackName}"
resolve_s3 = true
s3_prefix = "${config.stackName}"
region = "${config.region}"
confirm_changeset = false
capabilities = "CAPABILITY_IAM"
parameter_overrides = "${paramOverrides.join(' ')}"
disable_rollback = false

[default.build.parameters]
cached = true
parallel = true
`;

  const samConfigPath = join(BACKEND_DIR, 'samconfig.toml');
  writeFileSync(samConfigPath, samConfig);
  console.log('âœ“ Generated samconfig.toml');
  return samConfigPath;
}

/**
 * Runs SAM build
 */
async function runSamBuild() {
  console.log('\nğŸ“¦ Running SAM build...');

  return new Promise((resolve, reject) => {
    const proc = spawn('sam', ['build'], {
      cwd: BACKEND_DIR,
      stdio: 'inherit',
    });

    proc.on('close', (code) => {
      if (code === 0) {
        console.log('âœ“ SAM build completed');
        resolve();
      } else {
        reject(new Error(`SAM build failed with code ${code}`));
      }
    });

    proc.on('error', (error) => {
      reject(new Error(`Failed to start SAM build: ${error.message}`));
    });
  });
}

/**
 * Runs SAM deploy
 */
async function runSamDeploy() {
  console.log('\nğŸš€ Running SAM deploy...');

  return new Promise((resolve, reject) => {
    const proc = spawn('sam', ['deploy', '--no-confirm-changeset'], {
      cwd: BACKEND_DIR,
      stdio: 'inherit',
    });

    proc.on('close', (code) => {
      if (code === 0) {
        console.log('âœ“ SAM deploy completed');
        resolve();
      } else {
        reject(new Error(`SAM deploy failed with code ${code}`));
      }
    });

    proc.on('error', (error) => {
      reject(new Error(`Failed to start SAM deploy: ${error.message}`));
    });
  });
}

/**
 * Validates AWS stack name (alphanumeric, hyphens, underscores, 1-128 chars)
 */
function isValidStackName(name) {
  return /^[a-zA-Z0-9_-]{1,128}$/.test(name);
}

/**
 * Validates AWS region format (e.g., us-west-2, eu-central-1)
 */
function isValidRegion(region) {
  return /^[a-z]{2}-[a-z]+-\d{1}$/.test(region);
}

/**
 * Retrieves CloudFormation stack outputs
 */
function getStackOutputs(stackName, region) {
  console.log('\nğŸ“‹ Retrieving stack outputs...');

  // Validate inputs to prevent shell injection
  if (!isValidStackName(stackName)) {
    throw new Error(`Invalid stack name: ${stackName}. Must be alphanumeric with hyphens/underscores, 1-128 chars.`);
  }
  if (!isValidRegion(region)) {
    throw new Error(`Invalid region: ${region}. Must be a valid AWS region (e.g., us-west-2).`);
  }

  try {
    const result = execSync(
      `aws cloudformation describe-stacks --stack-name ${stackName} --region ${region} --query "Stacks[0].Outputs" --output json`,
      { encoding: 'utf-8' }
    );

    const outputs = JSON.parse(result);
    const outputMap = {};

    for (const output of outputs) {
      outputMap[output.OutputKey] = output.OutputValue;
    }

    return outputMap;
  } catch (error) {
    throw new Error(`Failed to get stack outputs: ${error.message}`);
  }
}

/**
 * Updates or creates .env file with stack outputs
 */
function updateEnvFile(outputs, config) {
  const envPath = join(PROJECT_ROOT, '.env');
  let existingEnv = {};

  // Read existing .env if it exists
  if (existsSync(envPath)) {
    const content = readFileSync(envPath, 'utf-8');
    for (const line of content.split('\n')) {
      const trimmed = line.trim();
      if (trimmed && !trimmed.startsWith('#')) {
        const [key, ...valueParts] = trimmed.split('=');
        if (key) {
          existingEnv[key] = valueParts.join('=');
        }
      }
    }
  }

  // Update with new values
  const updates = {
    VITE_API_GATEWAY_URL: outputs.ApiUrl || '',
    VITE_AWS_REGION: config.region,
    VITE_COGNITO_USER_POOL_ID: outputs.UserPoolId || '',
    VITE_COGNITO_USER_POOL_WEB_CLIENT_ID: outputs.UserPoolClientId || '',
    API_GATEWAY_BASE_URL: outputs.ApiUrl || '',
    AWS_REGION: config.region,
    S3_SCREENSHOT_BUCKET_NAME: outputs.ScreenshotBucketName || '',
    DYNAMODB_TABLE: outputs.DynamoDBTableName || '',
  };

  // Merge with existing
  const merged = { ...existingEnv, ...updates };

  // Write back
  const envContent = Object.entries(merged)
    .map(([key, value]) => `${key}=${value}`)
    .join('\n');

  writeFileSync(envPath, envContent + '\n');
  console.log('âœ“ Environment variables written to .env');

  // Display updates
  console.log('\nğŸ“ Updated .env with:');
  for (const [key, value] of Object.entries(updates)) {
    if (value) {
      console.log(`  ${key}=${value.substring(0, 50)}${value.length > 50 ? '...' : ''}`);
    }
  }
}

/**
 * Prompts for configuration values
 */
async function collectConfiguration(config) {
  console.log('\nğŸ“ SAM Deployment Configuration\n');

  config.stackName = await prompt('Stack name', config.stackName);
  config.region = await prompt('AWS region', config.region);
  config.environment = await prompt('Environment (dev/prod)', config.environment);

  console.log('\nğŸ“¦ Optional: API Keys (press Enter to skip)\n');

  config.openaiApiKey = await prompt('OpenAI API key', '', true);
  config.openaiWebhookSecret = await prompt('OpenAI webhook secret', '', true);

  // Check for RAGStack configuration
  const ragstackEnvPath = join(PROJECT_ROOT, '.env.ragstack');
  if (existsSync(ragstackEnvPath)) {
    console.log('\nâœ“ Found .env.ragstack - loading RAGStack configuration');
    const ragstackEnv = readFileSync(ragstackEnvPath, 'utf-8');

    // Helper to trim and strip surrounding quotes from env values
    const cleanEnvValue = (value) => {
      const trimmed = value.trim();
      // Remove surrounding single or double quotes
      return trimmed.replace(/^["']|["']$/g, '');
    };

    for (const line of ragstackEnv.split('\n')) {
      if (line.startsWith('RAGSTACK_GRAPHQL_ENDPOINT=')) {
        config.ragstackEndpoint = cleanEnvValue(line.substring(line.indexOf('=') + 1));
      }
      if (line.startsWith('RAGSTACK_API_KEY=')) {
        config.ragstackApiKey = cleanEnvValue(line.substring(line.indexOf('=') + 1));
      }
    }
  } else {
    config.ragstackEndpoint = await prompt('RAGStack GraphQL endpoint (optional)', '');
    config.ragstackApiKey = await prompt('RAGStack API key (optional)', '', true);
  }

  return config;
}

/**
 * Check for --dry-run flag
 */
function isDryRun() {
  return process.argv.includes('--dry-run');
}

/**
 * Main deployment flow
 */
async function main() {
  console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
  console.log('â•‘       LinkedIn Advanced Search - SAM Deployment            â•‘');
  console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');

  try {
    // Load or create configuration
    let config = loadConfig();

    // Check if this is a fresh deployment
    const configExists = existsSync(join(PROJECT_ROOT, CONFIG_FILE));

    if (!configExists) {
      config = await collectConfiguration(config);
    }

    // Validate prerequisites
    validateAwsCredentials();
    const accountId = getAwsAccountId();
    validateSamCli();

    // Save configuration (non-secrets only)
    saveConfig(config);

    // Generate SAM config
    generateSamConfig(config, accountId);

    if (isDryRun()) {
      console.log('\nğŸ” Dry run mode - skipping actual deployment');
      console.log('âœ“ Configuration validated');
      console.log('âœ“ samconfig.toml generated');
      return;
    }

    // Build and deploy
    await runSamBuild();
    await runSamDeploy();

    // Capture outputs
    const outputs = getStackOutputs(config.stackName, config.region);
    updateEnvFile(outputs, config);

    console.log('\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
    console.log('â•‘                  Deployment Complete!                       â•‘');
    console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');

    console.log('Stack Name:', config.stackName);
    console.log('Region:', config.region);
    console.log('Environment:', config.environment);
    console.log('\nAPI URL:', outputs.ApiUrl);
    console.log('\nNext steps:');
    console.log('1. Start frontend: npm run dev');
    console.log('2. Start puppeteer backend: npm run dev:puppeteer');
  } catch (error) {
    console.error('\nâŒ Deployment failed:', error.message);
    process.exit(1);
  }
}

// Run if executed directly
main();
