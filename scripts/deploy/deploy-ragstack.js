#!/usr/bin/env node
/**
 * RAGStack Deployment Script
 *
 * Deploys a dedicated RAGStack-Lambda instance for LinkedIn profile search.
 * - Prompts for configuration if not present
 * - Generates samconfig.toml
 * - Executes SAM build and deploy
 * - Captures outputs to .env.ragstack
 */

import { readFileSync, writeFileSync, existsSync } from 'fs';
import { execSync, spawn } from 'child_process';
import { createInterface } from 'readline';
import { homedir } from 'os';
import { resolve, join } from 'path';

const CONFIG_FILE = '.ragstack-config.json';
const ENV_FILE = '.env.ragstack';
const PROJECT_ROOT = resolve(process.cwd());

/**
 * Prompts user for input
 */
function prompt(question, defaultValue = '') {
  const rl = createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  return new Promise((resolve) => {
    const displayQuestion = defaultValue
      ? `${question} [${defaultValue}]: `
      : `${question}: `;

    rl.question(displayQuestion, (answer) => {
      rl.close();
      resolve(answer.trim() || defaultValue);
    });
  });
}

/**
 * Loads existing configuration or returns defaults
 */
function loadConfig() {
  const configPath = join(PROJECT_ROOT, CONFIG_FILE);

  if (existsSync(configPath)) {
    try {
      const config = JSON.parse(readFileSync(configPath, 'utf-8'));
      console.log('âœ“ Loaded existing configuration from', CONFIG_FILE);
      return config;
    } catch (error) {
      console.warn('âš  Failed to parse existing config, starting fresh');
    }
  }

  return {
    stackName: 'linkedin-profiles-kb',
    region: 'us-west-2',
    ragstackPath: join(homedir(), 'war', 'RAGStack-Lambda'),
    s3Bucket: '',
    bedrockModelAccess: false,
  };
}

/**
 * Saves configuration to file
 */
function saveConfig(config) {
  const configPath = join(PROJECT_ROOT, CONFIG_FILE);
  writeFileSync(configPath, JSON.stringify(config, null, 2));
  console.log('âœ“ Configuration saved to', CONFIG_FILE);
}

/**
 * Gets AWS account ID
 */
function getAwsAccountId() {
  try {
    const result = execSync('aws sts get-caller-identity --query Account --output text', {
      encoding: 'utf-8',
    });
    return result.trim();
  } catch (error) {
    throw new Error('Failed to get AWS account ID. Ensure AWS CLI is configured.');
  }
}

/**
 * Validates AWS credentials
 */
function validateAwsCredentials() {
  console.log('\nğŸ” Validating AWS credentials...');
  try {
    const identity = execSync('aws sts get-caller-identity --output json', {
      encoding: 'utf-8',
    });
    const parsed = JSON.parse(identity);
    console.log(`âœ“ Authenticated as: ${parsed.Arn}`);
    return true;
  } catch (error) {
    throw new Error('AWS credentials not configured or invalid. Run `aws configure` first.');
  }
}

/**
 * Checks Bedrock model access
 */
function checkBedrockAccess(region) {
  console.log('\nğŸ§  Checking Bedrock model access...');
  try {
    execSync(
      `aws bedrock list-foundation-models --region ${region} --query "modelSummaries[?contains(modelId, 'embed')]" --output json`,
      { encoding: 'utf-8' }
    );
    console.log('âœ“ Bedrock embedding models accessible');
    return true;
  } catch (error) {
    console.warn('âš  Could not verify Bedrock access. Ensure Nova Embeddings is enabled in', region);
    return false;
  }
}

/**
 * Validates RAGStack-Lambda repository exists
 */
function validateRagstackPath(ragstackPath) {
  const templatePath = join(ragstackPath, 'template.yaml');
  if (!existsSync(templatePath)) {
    throw new Error(
      `RAGStack-Lambda not found at ${ragstackPath}.\n` +
        'Clone it: git clone https://github.com/aws-samples/RAGStack-Lambda.git ~/war/RAGStack-Lambda'
    );
  }
  console.log('âœ“ RAGStack-Lambda repository found');
  return true;
}

/**
 * Generates samconfig.toml for RAGStack deployment
 */
function generateSamConfig(config, accountId) {
  const s3Bucket = config.s3Bucket || `${config.stackName}-${accountId}-artifacts`;

  const samConfig = `# Auto-generated by deploy-ragstack.js
# Do not edit manually

version = 0.1

[default.deploy.parameters]
stack_name = "${config.stackName}"
resolve_s3 = true
s3_prefix = "${config.stackName}"
region = "${config.region}"
confirm_changeset = false
capabilities = "CAPABILITY_IAM CAPABILITY_AUTO_EXPAND"
parameter_overrides = "EmbeddingModelId=amazon.nova-embed-multimodal-v1 VectorStoreType=s3"
disable_rollback = false

[default.build.parameters]
cached = true
parallel = true
`;

  const samConfigPath = join(config.ragstackPath, 'samconfig.toml');
  writeFileSync(samConfigPath, samConfig);
  console.log('âœ“ Generated samconfig.toml');
  return samConfigPath;
}

/**
 * Runs SAM build
 */
async function runSamBuild(ragstackPath) {
  console.log('\nğŸ“¦ Running SAM build...');

  return new Promise((resolve, reject) => {
    const proc = spawn('sam', ['build'], {
      cwd: ragstackPath,
      stdio: 'inherit',
    });

    proc.on('close', (code) => {
      if (code === 0) {
        console.log('âœ“ SAM build completed');
        resolve();
      } else {
        reject(new Error(`SAM build failed with code ${code}`));
      }
    });

    proc.on('error', (error) => {
      reject(new Error(`Failed to start SAM build: ${error.message}`));
    });
  });
}

/**
 * Runs SAM deploy
 */
async function runSamDeploy(ragstackPath) {
  console.log('\nğŸš€ Running SAM deploy...');

  return new Promise((resolve, reject) => {
    const proc = spawn('sam', ['deploy', '--no-confirm-changeset'], {
      cwd: ragstackPath,
      stdio: 'inherit',
    });

    proc.on('close', (code) => {
      if (code === 0) {
        console.log('âœ“ SAM deploy completed');
        resolve();
      } else {
        reject(new Error(`SAM deploy failed with code ${code}`));
      }
    });

    proc.on('error', (error) => {
      reject(new Error(`Failed to start SAM deploy: ${error.message}`));
    });
  });
}

/**
 * Retrieves CloudFormation stack outputs
 */
function getStackOutputs(stackName, region) {
  console.log('\nğŸ“‹ Retrieving stack outputs...');

  try {
    const result = execSync(
      `aws cloudformation describe-stacks --stack-name ${stackName} --region ${region} --query "Stacks[0].Outputs" --output json`,
      { encoding: 'utf-8' }
    );

    const outputs = JSON.parse(result);
    const outputMap = {};

    for (const output of outputs) {
      outputMap[output.OutputKey] = output.OutputValue;
    }

    return outputMap;
  } catch (error) {
    throw new Error(`Failed to get stack outputs: ${error.message}`);
  }
}

/**
 * Retrieves AppSync API key
 */
function getApiKey(apiId, region) {
  try {
    const result = execSync(
      `aws appsync list-api-keys --api-id ${apiId} --region ${region} --query "apiKeys[0].id" --output text`,
      { encoding: 'utf-8' }
    );
    return result.trim();
  } catch (error) {
    console.warn('âš  Could not retrieve API key automatically');
    return '';
  }
}

/**
 * Writes environment variables to .env.ragstack
 */
function writeEnvFile(outputs, config) {
  const graphqlEndpoint = outputs.GraphQLApiEndpoint || outputs.GraphQLEndpoint || '';
  const apiId = outputs.GraphQLApiId || '';
  const kbId = outputs.KnowledgeBaseId || '';
  const dataSourceId = outputs.TextDataSourceId || outputs.DataSourceId || '';

  // Try to get API key
  let apiKey = '';
  if (apiId) {
    apiKey = getApiKey(apiId, config.region);
  }

  const envContent = `# RAGStack Configuration
# Auto-generated by deploy-ragstack.js

RAGSTACK_GRAPHQL_ENDPOINT=${graphqlEndpoint}
RAGSTACK_API_KEY=${apiKey}
RAGSTACK_API_ID=${apiId}
RAGSTACK_KB_ID=${kbId}
RAGSTACK_DATA_SOURCE_ID=${dataSourceId}
RAGSTACK_REGION=${config.region}
RAGSTACK_STACK_NAME=${config.stackName}
`;

  const envPath = join(PROJECT_ROOT, ENV_FILE);
  writeFileSync(envPath, envContent);
  console.log('âœ“ Environment variables written to', ENV_FILE);
}

/**
 * Prompts for missing configuration values
 */
async function collectConfiguration(config) {
  console.log('\nğŸ“ RAGStack Configuration\n');

  config.stackName = await prompt('Stack name', config.stackName);
  config.region = await prompt('AWS region', config.region);
  config.ragstackPath = await prompt(
    'Path to RAGStack-Lambda repository',
    config.ragstackPath
  );

  // Expand ~ in path
  if (config.ragstackPath.startsWith('~')) {
    config.ragstackPath = config.ragstackPath.replace('~', homedir());
  }

  return config;
}

/**
 * Main deployment flow
 */
async function main() {
  console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
  console.log('â•‘          RAGStack Deployment for LinkedIn Profiles         â•‘');
  console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');

  try {
    // Load or create configuration
    let config = loadConfig();

    // Check if this is a fresh deployment
    const configExists = existsSync(join(PROJECT_ROOT, CONFIG_FILE));

    if (!configExists) {
      config = await collectConfiguration(config);
    }

    // Validate prerequisites
    validateAwsCredentials();
    const accountId = getAwsAccountId();
    validateRagstackPath(config.ragstackPath);
    config.bedrockModelAccess = checkBedrockAccess(config.region);

    // Save configuration
    saveConfig(config);

    // Generate SAM config
    generateSamConfig(config, accountId);

    // Build and deploy
    await runSamBuild(config.ragstackPath);
    await runSamDeploy(config.ragstackPath);

    // Capture outputs
    const outputs = getStackOutputs(config.stackName, config.region);
    writeEnvFile(outputs, config);

    console.log('\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
    console.log('â•‘                  Deployment Complete! ğŸ‰                    â•‘');
    console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');

    console.log('Stack Name:', config.stackName);
    console.log('Region:', config.region);
    console.log('\nOutputs saved to:', ENV_FILE);
    console.log('\nNext steps:');
    console.log('1. Source the environment: source .env.ragstack');
    console.log('2. Deploy the main application: npm run deploy');
  } catch (error) {
    console.error('\nâŒ Deployment failed:', error.message);
    process.exit(1);
  }
}

// Run if executed directly
main();
